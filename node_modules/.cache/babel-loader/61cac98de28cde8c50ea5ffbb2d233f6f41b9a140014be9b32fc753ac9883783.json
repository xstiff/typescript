{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { extend } from '../../../utils/object.js';\nimport { createMatAlgo13xDD } from './matAlgo13xDD.js';\nimport { createMatAlgo14xDs } from './matAlgo14xDs.js';\nvar name = 'matrixAlgorithmSuite';\nvar dependencies = ['typed', 'matrix'];\nexport var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  var matAlgo13xDD = createMatAlgo13xDD({\n    typed\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n\n  /**\n   * Return a signatures object with the usual boilerplate of\n   * matrix algorithms, based on a plain options object with the\n   * following properties:\n   *   elop: function -- the elementwise operation to use, defaults to self\n   *   SS: function -- the algorithm to apply for two sparse matrices\n   *   DS: function -- the algorithm to apply for a dense and a sparse matrix\n   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped\n   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar\n   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped\n   *   scalar: string -- typed-function type for scalars, defaults to 'any'\n   *\n   * If Ss is not specified, no matrix-scalar signatures are generated.\n   *\n   * @param {object} options\n   * @return {Object<string, function>} signatures\n   */\n  return function matrixAlgorithmSuite(options) {\n    var elop = options.elop;\n    var SD = options.SD || options.DS;\n    var matrixSignatures;\n    if (elop) {\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': (x, y) => matAlgo13xDD(x, y, elop),\n        'Array, Array': (x, y) => matAlgo13xDD(matrix(x), matrix(y), elop).valueOf(),\n        'Array, DenseMatrix': (x, y) => matAlgo13xDD(matrix(x), y, elop),\n        'DenseMatrix, Array': (x, y) => matAlgo13xDD(x, matrix(y), elop)\n      };\n      // Now incorporate sparse matrices\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y) => options.SS(x, y, elop, false);\n      }\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y) => options.DS(x, y, elop, false);\n        matrixSignatures['Array, SparseMatrix'] = (x, y) => options.DS(matrix(x), y, elop, false);\n      }\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y) => SD(y, x, elop, true);\n        matrixSignatures['SparseMatrix, Array'] = (x, y) => SD(matrix(y), x, elop, true);\n      }\n    } else {\n      // No elop, use this\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(x, y, self);\n        }),\n        'Array, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(matrix(x), matrix(y), self).valueOf();\n        }),\n        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(matrix(x), y, self);\n        }),\n        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(x, matrix(y), self);\n        })\n      };\n      // Now incorporate sparse matrices\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.SS(x, y, self, false);\n        });\n      }\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(x, y, self, false);\n        });\n        matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(matrix(x), y, self, false);\n        });\n      }\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return SD(y, x, self, true);\n        });\n        matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(self => (x, y) => {\n          return SD(matrix(y), x, self, true);\n        });\n      }\n    }\n\n    // Now add the scalars\n    var scalar = options.scalar || 'any';\n    var Ds = options.Ds || options.Ss;\n    if (Ds) {\n      if (elop) {\n        matrixSignatures['DenseMatrix,' + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);\n        matrixSignatures[scalar + ', DenseMatrix'] = (x, y) => matAlgo14xDs(y, x, elop, true);\n        matrixSignatures['Array,' + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();\n        matrixSignatures[scalar + ', Array'] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();\n      } else {\n        matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(x, y, self, false);\n        });\n        matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(y, x, self, true);\n        });\n        matrixSignatures['Array,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(x), y, self, false).valueOf();\n        });\n        matrixSignatures[scalar + ', Array'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n        });\n      }\n    }\n    var sS = options.sS !== undefined ? options.sS : options.Ss;\n    if (elop) {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = (x, y) => options.Ss(x, y, elop, false);\n      }\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = (x, y) => sS(y, x, elop, true);\n      }\n    } else {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return options.Ss(x, y, self, false);\n        });\n      }\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return sS(y, x, self, true);\n        });\n      }\n    }\n    // Also pull in the scalar signatures if the operator is a typed function\n    if (elop && elop.signatures) {\n      extend(matrixSignatures, elop.signatures);\n    }\n    return matrixSignatures;\n  };\n});","map":{"version":3,"names":["factory","extend","createMatAlgo13xDD","createMatAlgo14xDs","name","dependencies","createMatrixAlgorithmSuite","_ref","typed","matrix","matAlgo13xDD","matAlgo14xDs","matrixAlgorithmSuite","options","elop","SD","DS","matrixSignatures","x","y","valueOf","SS","referToSelf","self","scalar","Ds","Ss","sS","undefined","signatures"],"sources":["C:/Users/domin/Desktop/Zadanie/zad/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { extend } from '../../../utils/object.js';\nimport { createMatAlgo13xDD } from './matAlgo13xDD.js';\nimport { createMatAlgo14xDs } from './matAlgo14xDs.js';\nvar name = 'matrixAlgorithmSuite';\nvar dependencies = ['typed', 'matrix'];\nexport var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  var matAlgo13xDD = createMatAlgo13xDD({\n    typed\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n\n  /**\n   * Return a signatures object with the usual boilerplate of\n   * matrix algorithms, based on a plain options object with the\n   * following properties:\n   *   elop: function -- the elementwise operation to use, defaults to self\n   *   SS: function -- the algorithm to apply for two sparse matrices\n   *   DS: function -- the algorithm to apply for a dense and a sparse matrix\n   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped\n   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar\n   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped\n   *   scalar: string -- typed-function type for scalars, defaults to 'any'\n   *\n   * If Ss is not specified, no matrix-scalar signatures are generated.\n   *\n   * @param {object} options\n   * @return {Object<string, function>} signatures\n   */\n  return function matrixAlgorithmSuite(options) {\n    var elop = options.elop;\n    var SD = options.SD || options.DS;\n    var matrixSignatures;\n    if (elop) {\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': (x, y) => matAlgo13xDD(x, y, elop),\n        'Array, Array': (x, y) => matAlgo13xDD(matrix(x), matrix(y), elop).valueOf(),\n        'Array, DenseMatrix': (x, y) => matAlgo13xDD(matrix(x), y, elop),\n        'DenseMatrix, Array': (x, y) => matAlgo13xDD(x, matrix(y), elop)\n      };\n      // Now incorporate sparse matrices\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y) => options.SS(x, y, elop, false);\n      }\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y) => options.DS(x, y, elop, false);\n        matrixSignatures['Array, SparseMatrix'] = (x, y) => options.DS(matrix(x), y, elop, false);\n      }\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y) => SD(y, x, elop, true);\n        matrixSignatures['SparseMatrix, Array'] = (x, y) => SD(matrix(y), x, elop, true);\n      }\n    } else {\n      // No elop, use this\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(x, y, self);\n        }),\n        'Array, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(matrix(x), matrix(y), self).valueOf();\n        }),\n        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(matrix(x), y, self);\n        }),\n        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(x, matrix(y), self);\n        })\n      };\n      // Now incorporate sparse matrices\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.SS(x, y, self, false);\n        });\n      }\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(x, y, self, false);\n        });\n        matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(matrix(x), y, self, false);\n        });\n      }\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return SD(y, x, self, true);\n        });\n        matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(self => (x, y) => {\n          return SD(matrix(y), x, self, true);\n        });\n      }\n    }\n\n    // Now add the scalars\n    var scalar = options.scalar || 'any';\n    var Ds = options.Ds || options.Ss;\n    if (Ds) {\n      if (elop) {\n        matrixSignatures['DenseMatrix,' + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);\n        matrixSignatures[scalar + ', DenseMatrix'] = (x, y) => matAlgo14xDs(y, x, elop, true);\n        matrixSignatures['Array,' + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();\n        matrixSignatures[scalar + ', Array'] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();\n      } else {\n        matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(x, y, self, false);\n        });\n        matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(y, x, self, true);\n        });\n        matrixSignatures['Array,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(x), y, self, false).valueOf();\n        });\n        matrixSignatures[scalar + ', Array'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n        });\n      }\n    }\n    var sS = options.sS !== undefined ? options.sS : options.Ss;\n    if (elop) {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = (x, y) => options.Ss(x, y, elop, false);\n      }\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = (x, y) => sS(y, x, elop, true);\n      }\n    } else {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return options.Ss(x, y, self, false);\n        });\n      }\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return sS(y, x, self, true);\n        });\n      }\n    }\n    // Also pull in the scalar signatures if the operator is a typed function\n    if (elop && elop.signatures) {\n      extend(matrixSignatures, elop.signatures);\n    }\n    return matrixSignatures;\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}