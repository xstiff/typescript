{"ast":null,"code":"import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    divideScalar,\n    exp,\n    tau,\n    i: I\n  } = _ref;\n  /**\n   * Calculate N-dimensional fourier transform\n   *\n   * Syntax:\n   *\n   *     math.fft(arr)\n   *\n   * Examples:\n   *\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\n   *\n   *\n   * See Also:\n   *\n   *      ifft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\n   */\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.toArray()));\n    }\n  });\n\n  /**\n   * Perform an N-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]);\n    // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\n  }\n\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     dimension of the array to perform on\n   * @return {Array}         resulting array\n   */\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\n    if (size.length === 1) return _fft(arr);\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\n    }\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n    if (len % 2 === 0) {\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n      return ret;\n    }\n    throw new Error('Can only calculate FFT of power-of-two size');\n  }\n});","map":{"version":3,"names":["arraySize","factory","name","dependencies","createFft","_ref","typed","matrix","addScalar","multiplyScalar","divideScalar","exp","tau","i","I","Array","_ndFft","Matrix","create","toArray","arr","size","length","_fft","_1dFft","map","slice","dim","fill","_","_transpose","j","len","ret","filter","k","p","q","Error"],"sources":["C:/Users/domin/Desktop/Zadanie/zad/node_modules/mathjs/lib/esm/function/matrix/fft.js"],"sourcesContent":["import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    divideScalar,\n    exp,\n    tau,\n    i: I\n  } = _ref;\n  /**\n   * Calculate N-dimensional fourier transform\n   *\n   * Syntax:\n   *\n   *     math.fft(arr)\n   *\n   * Examples:\n   *\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\n   *\n   *\n   * See Also:\n   *\n   *      ifft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\n   */\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.toArray()));\n    }\n  });\n\n  /**\n   * Perform an N-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]);\n    // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\n  }\n\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     dimension of the array to perform on\n   * @return {Array}         resulting array\n   */\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\n    if (size.length === 1) return _fft(arr);\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\n    }\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n    if (len % 2 === 0) {\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n      return ret;\n    }\n    throw new Error('Can only calculate FFT of power-of-two size');\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}